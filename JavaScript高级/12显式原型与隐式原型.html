<!DOCTYPE html5>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>12显式原型与隐式原型</title>
  
</head>
<body>

  <!-- 
    
    function Fn () {} ===> var Fn = new Function()
      所以构造函数也是一个实例对象，是Function构造函数的实例对象，它也有__proto__属性
      结论：所以函数都有两个属性：显示原型(prototype)和隐式原型(__proto__)
        注： function Function() 自身的显示原型与它自身的隐式原型值是一样de
             function Function()既是构造函数又是函数实例对象（它是New自己创建de）===》 Function = new Function()
  -->
<!-- 任何函数都是new Function() 产生的 所以任意一函数都是Function 的实例对象
   所有函数的__proto__隐式原型都是一样的,都指向Function（）的prototype的显式原型
 -->
  <!-- 
    Object()是大写Function的实例对象
 
   -->


    <!-- 
        1.每个函数function都拥有一个prototype，即显式原型 默认指向一个空的Object对象(没我们主动添加的属性)
        2.每一个构造函数的实例对象都拥有一个__proto__,可称为隐式原型
        3.对象的隐式原型的值为其对应构造函数的显式原型的值
        4.内存结构图（图）
        5.总结:
            函数function的prototype属性：在定义函数时自动添加的，默认值是一个空的Oject对象
            对象的__proto__属性：创建对象时自动添加的，默认值为构造函数的prototype属性值
            程序员能直接操作显示原型，当不能操作隐式原型（ES6之前）

     -->
     <script>
         function Fun (){
              //内部语句 this.prototype={} 

         }
         // 1.每个函数function都拥有一个prototype，即显式原型 默认指向一个空的Object对象
         console.log("下面输出的是函数的显示原型prototype")
         console.log(Fun.prototype)

         // 2.每一个实例对象都拥有一个__proto__,可称为隐式原型
         console.log('下面输出的是函数的显示原型')
         var fn=new Fun ()  //内部语句： this.__proto__=Fun.prototype
         
         console.log(fn.__proto__)
         //3.对象的隐式原型的值为其对应构造函数的显式原型的值
         console.log('下面判断构造函数的显示原型prototype是否等于该构造函数的实例对象的隐式原型__proto__');
         console.log(Fun.prototype===fn.__proto__);

         //给构造函数的原型函数添加方法
          Fun.prototype.test=function(){
            console.log('这是通过构造函数原型函数添加的方法test()');
          }
        //实例对象调用构造函数原型中的方法
        fn.__proto__.test();
     </script>
</body>
</html>